;
; File generated by cc65 v 2.18 - Ubuntu 2.18-1
;
	.fopt		compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	on
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.dbg		file, "sieve.c", 2876, 1615619520
	.dbg		file, "/usr/share/cc65/include/stdlib.h", 5748, 1573331006
	.dbg		file, "/usr/share/cc65/include/stdio.h", 6189, 1573331006
	.dbg		file, "/usr/share/cc65/include/stddef.h", 3057, 1573331006
	.dbg		file, "/usr/share/cc65/include/stdarg.h", 2913, 1573331006
	.dbg		file, "/usr/share/cc65/include/ctype.h", 8462, 1573331006
	.dbg		file, "/usr/share/cc65/include/time.h", 5941, 1573331006
	.dbg		file, "/usr/share/cc65/include/conio.h", 8941, 1573331006
	.dbg		file, "/usr/share/cc65/include/target.h", 2992, 1573331006
	.dbg		file, "/usr/share/cc65/include/atari.h", 21597, 1573331006
	.dbg		file, "/usr/share/cc65/include/_atarios.h", 41120, 1573331006
	.dbg		file, "/usr/share/cc65/include/_gtia.h", 13839, 1573331006
	.dbg		file, "/usr/share/cc65/include/_pbi.h", 3143, 1573331006
	.dbg		file, "/usr/share/cc65/include/_pokey.h", 11387, 1573331006
	.dbg		file, "/usr/share/cc65/include/_pia.h", 3044, 1573331006
	.dbg		file, "/usr/share/cc65/include/_antic.h", 11828, 1573331006
	.forceimport	__STARTUP__
	.dbg		sym, "printf", "00", extern, "_printf"
	.dbg		sym, "toupper", "00", extern, "_toupper"
	.dbg		sym, "_clocks_per_sec", "00", extern, "__clocks_per_sec"
	.dbg		sym, "clock", "00", extern, "_clock"
	.dbg		sym, "kbhit", "00", extern, "_kbhit"
	.dbg		sym, "cgetc", "00", extern, "_cgetc"
	.import		_printf
	.import		_toupper
	.import		__clocks_per_sec
	.import		_clock
	.import		_kbhit
	.import		_cgetc
	.export		_main

.segment	"RODATA"

L002D:
	.byte	$53,$69,$65,$76,$65,$20,$62,$65,$6E,$63,$68,$6D,$61,$72,$6B,$20
	.byte	$2D,$20,$63,$61,$6C,$63,$75,$6C,$61,$74,$69,$6E,$67,$20,$70,$72
	.byte	$69,$6D,$65,$73,$9B,$00
L007D:
	.byte	$51,$20,$74,$6F,$20,$71,$75,$69,$74,$2C,$20,$61,$6E,$79,$20,$6F
	.byte	$74,$68,$65,$72,$20,$6B,$65,$79,$20,$63,$6F,$6E,$74,$69,$6E,$75
	.byte	$65,$73,$9B,$00
L0062:
	.byte	$51,$20,$74,$6F,$20,$71,$75,$69,$74,$2C,$20,$61,$6E,$79,$20,$6F
	.byte	$74,$68,$65,$72,$20,$6B,$65,$79,$20,$66,$6F,$72,$20,$6C,$69,$73
	.byte	$74,$9B,$00
L005D:
	.byte	$54,$69,$6D,$65,$20,$75,$73,$65,$64,$3A,$20,$25,$75,$2E,$25,$30
	.byte	$33,$75,$20,$73,$65,$63,$6F,$6E,$64,$73,$9B,$00
L0034:
	.byte	$50,$6C,$65,$61,$73,$65,$20,$77,$61,$69,$74,$20,$70,$61,$74,$69
	.byte	$65,$6E,$74,$6C,$79,$20,$2E,$2E,$2E,$9B,$00
L0030:
	.byte	$62,$65,$74,$77,$65,$65,$6E,$20,$32,$20,$61,$6E,$64,$20,$25,$75
	.byte	$9B,$00
L0075:
	.byte	$25,$34,$64,$9B,$00

.segment	"BSS"

_Sieve:
	.res	16384,$00

; ---------------------------------------------------------------
; unsigned char __near__ ReadUpperKey (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ReadUpperKey: near

	.dbg	func, "ReadUpperKey", "00", static, "_ReadUpperKey"

.segment	"CODE"

;
; return toupper (cgetc ());
;
	.dbg	line, "sieve.c", 48
	jsr     _cgetc
	ldx     #$00
	jsr     _toupper
	ldx     #$00
;
; }
;
	.dbg	line, "sieve.c", 49
	rts
	.dbg	line

.endproc

; ---------------------------------------------------------------
; int __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

	.dbg	func, "main", "00", extern, "_main"
	.dbg	sym, "S", "00", register, "regbank", 4
	.dbg	sym, "I", "00", register, "regbank", 2
	.dbg	sym, "J", "00", register, "regbank", 0

.segment	"BSS"

L0029:
	.res	4,$00
L002A:
	.res	2,$00
L002B:
	.res	2,$00

.segment	"CODE"

;
; register unsigned char* S;
;
	.dbg	line, "sieve.c", 61
	lda     regbank+4
	ldx     regbank+5
	jsr     pushax
;
; register unsigned       I;
;
	.dbg	line, "sieve.c", 62
	lda     regbank+2
	ldx     regbank+3
	jsr     pushax
;
; register unsigned       J;
;
	.dbg	line, "sieve.c", 63
	lda     regbank+0
	ldx     regbank+1
	jsr     pushax
;
; printf ("Sieve benchmark - calculating primes\n");
;
	.dbg	line, "sieve.c", 66
	lda     #<(L002D)
	ldx     #>(L002D)
	jsr     pushax
	ldy     #$02
	jsr     _printf
;
; printf ("between 2 and %u\n", COUNT);
;
	.dbg	line, "sieve.c", 67
	lda     #<(L0030)
	ldx     #>(L0030)
	jsr     pushax
	ldx     #$40
	lda     #$00
	jsr     pushax
	ldy     #$04
	jsr     _printf
;
; printf ("Please wait patiently ...\n");
;
	.dbg	line, "sieve.c", 68
	lda     #<(L0034)
	ldx     #>(L0034)
	jsr     pushax
	ldy     #$02
	jsr     _printf
;
; Ticks = clock();
;
	.dbg	line, "sieve.c", 71
	jsr     _clock
	sta     L0029
	stx     L0029+1
	ldy     sreg
	sty     L0029+2
	ldy     sreg+1
	sty     L0029+3
;
; I = 2;
;
	.dbg	line, "sieve.c", 74
	ldx     #$00
	lda     #$02
	sta     regbank+2
	stx     regbank+2+1
;
; while (I < SQRT_COUNT) {
;
	.dbg	line, "sieve.c", 75
	jmp     L003C
;
; if (Sieve[I] == 0) {
;
	.dbg	line, "sieve.c", 76
L003A:	lda     #<(_Sieve)
	sta     ptr1
	lda     #>(_Sieve)
	clc
	adc     regbank+2+1
	sta     ptr1+1
	ldy     regbank+2
	lda     (ptr1),y
	bne     L0048
;
; J = I*2;
;
	.dbg	line, "sieve.c", 78
	lda     regbank+2
	asl     a
	sta     regbank+0
	lda     regbank+2+1
	rol     a
	sta     regbank+0+1
;
; S = &Sieve[J];
;
	.dbg	line, "sieve.c", 79
	lda     #<(_Sieve)
	clc
	adc     regbank+0
	sta     regbank+4
	lda     #>(_Sieve)
	adc     regbank+0+1
	sta     regbank+4+1
;
; while (J < COUNT) {
;
	.dbg	line, "sieve.c", 80
	jmp     L0049
;
; *S = 1;
;
	.dbg	line, "sieve.c", 81
L0047:	lda     #$01
	ldy     #$00
	sta     (regbank+4),y
;
; S += I;
;
	.dbg	line, "sieve.c", 82
	lda     regbank+2
	clc
	adc     regbank+4
	sta     regbank+4
	lda     regbank+2+1
	adc     regbank+4+1
	sta     regbank+4+1
;
; J += I;
;
	.dbg	line, "sieve.c", 83
	lda     regbank+2
	clc
	adc     regbank+0
	sta     regbank+0
	lda     regbank+2+1
	adc     regbank+0+1
	sta     regbank+0+1
;
; while (J < COUNT) {
;
	.dbg	line, "sieve.c", 80
L0049:	ldx     regbank+0+1
	cpx     #$40
	bcc     L0047
;
; ++I;
;
	.dbg	line, "sieve.c", 86
L0048:	inc     regbank+2
	bne     L003C
	inc     regbank+2+1
;
; while (I < SQRT_COUNT) {
;
	.dbg	line, "sieve.c", 75
L003C:	lda     regbank+2+1
	cmp     #$00
	bne     L003E
	lda     regbank+2
	cmp     #$80
L003E:	bcc     L003A
;
; Ticks = clock() - Ticks;
;
	.dbg	line, "sieve.c", 90
	jsr     _clock
	jsr     pusheax
	lda     L0029+3
	sta     sreg+1
	lda     L0029+2
	sta     sreg
	ldx     L0029+1
	lda     L0029
	jsr     tossubeax
	sta     L0029
	stx     L0029+1
	ldy     sreg
	sty     L0029+2
	ldy     sreg+1
	sty     L0029+3
;
; Sec = (unsigned) (Ticks / CLOCKS_PER_SEC);
;
	.dbg	line, "sieve.c", 91
	lda     L0029+3
	sta     sreg+1
	lda     L0029+2
	sta     sreg
	ldx     L0029+1
	lda     L0029
	jsr     pusheax
	jsr     __clocks_per_sec
	jsr     tosudiv0ax
	sta     L002A
	stx     L002A+1
;
; Milli = ((Ticks % CLOCKS_PER_SEC) * 1000) / CLOCKS_PER_SEC;
;
	.dbg	line, "sieve.c", 92
	lda     L0029+3
	sta     sreg+1
	lda     L0029+2
	sta     sreg
	ldx     L0029+1
	lda     L0029
	jsr     pusheax
	jsr     __clocks_per_sec
	jsr     tosumod0ax
	jsr     pusheax
	ldx     #$03
	lda     #$E8
	jsr     tosumul0ax
	jsr     pusheax
	jsr     __clocks_per_sec
	jsr     tosudiv0ax
	sta     L002B
	stx     L002B+1
;
; printf ("Time used: %u.%03u seconds\n", Sec, Milli);
;
	.dbg	line, "sieve.c", 95
	lda     #<(L005D)
	ldx     #>(L005D)
	jsr     pushax
	lda     L002A
	ldx     L002A+1
	jsr     pushax
	lda     L002B
	ldx     L002B+1
	jsr     pushax
	ldy     #$06
	jsr     _printf
;
; printf ("Q to quit, any other key for list\n");
;
	.dbg	line, "sieve.c", 96
	lda     #<(L0062)
	ldx     #>(L0062)
	jsr     pushax
	ldy     #$02
	jsr     _printf
;
; if (ReadUpperKey () != 'Q') {
;
	.dbg	line, "sieve.c", 99
	jsr     _ReadUpperKey
	cmp     #$51
	beq     L0069
;
; J = 0;
;
	.dbg	line, "sieve.c", 101
	ldx     #$00
	txa
	sta     regbank+0
	sta     regbank+0+1
;
; for (I = 2; I < COUNT; ++I) {
;
	.dbg	line, "sieve.c", 102
	lda     #$02
	sta     regbank+2
	stx     regbank+2+1
L0068:	ldx     regbank+2+1
	cpx     #$40
	bcs     L0069
;
; if (Sieve[I] == 0) {
;
	.dbg	line, "sieve.c", 103
	lda     #<(_Sieve)
	sta     ptr1
	lda     #>(_Sieve)
	clc
	adc     regbank+2+1
	sta     ptr1+1
	ldy     regbank+2
	lda     (ptr1),y
	bne     L0078
;
; printf ("%4d\n", I);
;
	.dbg	line, "sieve.c", 104
	lda     #<(L0075)
	ldx     #>(L0075)
	jsr     pushax
	lda     regbank+2
	ldx     regbank+2+1
	jsr     pushax
	ldy     #$04
	jsr     _printf
;
; if (++J == 23) {
;
	.dbg	line, "sieve.c", 105
	inc     regbank+0
	bne     L007A
	inc     regbank+0+1
L007A:	lda     regbank+0+1
	bne     L0078
	lda     regbank+0
	cmp     #$17
	bne     L0078
;
; printf ("Q to quit, any other key continues\n");
;
	.dbg	line, "sieve.c", 106
	lda     #<(L007D)
	ldx     #>(L007D)
	jsr     pushax
	ldy     #$02
	jsr     _printf
;
; if (ReadUpperKey () == 'Q') {
;
	.dbg	line, "sieve.c", 107
	jsr     _ReadUpperKey
	cmp     #$51
;
; break;
;
	.dbg	line, "sieve.c", 108
	beq     L0069
;
; J = 0;
;
	.dbg	line, "sieve.c", 110
	lda     #$00
	sta     regbank+0
	sta     regbank+0+1
;
; if (kbhit() && ReadUpperKey () == 'Q') {
;
	.dbg	line, "sieve.c", 113
L0078:	jsr     _kbhit
	tax
	beq     L006A
	jsr     _ReadUpperKey
	cmp     #$51
	beq     L0069
;
; for (I = 2; I < COUNT; ++I) {
;
	.dbg	line, "sieve.c", 102
L006A:	inc     regbank+2
	bne     L0068
	inc     regbank+2+1
	jmp     L0068
;
; return EXIT_SUCCESS;
;
	.dbg	line, "sieve.c", 119
L0069:	ldx     #$00
	txa
;
; }
;
	.dbg	line, "sieve.c", 120
	pha
	tay
L0088:	lda     (sp),y
	sta     regbank+0,y
	iny
	cpy     #$06
	bne     L0088
	pla
	jmp     incsp6
	.dbg	line

.endproc

